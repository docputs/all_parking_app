// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'auth_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$AuthFailureTearOff {
  const _$AuthFailureTearOff();

// ignore: unused_element
  _EmptyField emptyField(String message) {
    return _EmptyField(
      message,
    );
  }

// ignore: unused_element
  _DisplayNameTooLong displayNameTooLong(String message) {
    return _DisplayNameTooLong(
      message,
    );
  }

// ignore: unused_element
  _EmailAlreadyInUse emailAlreadyInUse(String message) {
    return _EmailAlreadyInUse(
      message,
    );
  }

// ignore: unused_element
  _CancelledByUser cancelledByUser(String message) {
    return _CancelledByUser(
      message,
    );
  }

// ignore: unused_element
  _InvalidEmailAddress invalidEmailAddress(String message) {
    return _InvalidEmailAddress(
      message,
    );
  }

// ignore: unused_element
  _InvalidEmailAndPasswordCombination invalidEmailAndPasswordCombination(
      String message) {
    return _InvalidEmailAndPasswordCombination(
      message,
    );
  }

// ignore: unused_element
  _EmailBadlyFormatted emailBadlyFormatted(String message) {
    return _EmailBadlyFormatted(
      message,
    );
  }

// ignore: unused_element
  _WeakPassword weakPassword(String message) {
    return _WeakPassword(
      message,
    );
  }

// ignore: unused_element
  _ServerFailure serverFailure(String message) {
    return _ServerFailure(
      message,
    );
  }

// ignore: unused_element
  _UnknownFailure unknownFailure(String message) {
    return _UnknownFailure(
      message,
    );
  }

// ignore: unused_element
  _PasswordsDontMatch passwordsDontMatch(String message) {
    return _PasswordsDontMatch(
      message,
    );
  }

// ignore: unused_element
  _NotAuthenticated notAuthenticated(String message) {
    return _NotAuthenticated(
      message,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $AuthFailure = _$AuthFailureTearOff();

/// @nodoc
mixin _$AuthFailure {
  String get message;

  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  });

  @JsonKey(ignore: true)
  $AuthFailureCopyWith<AuthFailure> get copyWith;
}

/// @nodoc
abstract class $AuthFailureCopyWith<$Res> {
  factory $AuthFailureCopyWith(
          AuthFailure value, $Res Function(AuthFailure) then) =
      _$AuthFailureCopyWithImpl<$Res>;
  $Res call({String message});
}

/// @nodoc
class _$AuthFailureCopyWithImpl<$Res> implements $AuthFailureCopyWith<$Res> {
  _$AuthFailureCopyWithImpl(this._value, this._then);

  final AuthFailure _value;
  // ignore: unused_field
  final $Res Function(AuthFailure) _then;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_value.copyWith(
      message: message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
abstract class _$EmptyFieldCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$EmptyFieldCopyWith(
          _EmptyField value, $Res Function(_EmptyField) then) =
      __$EmptyFieldCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$EmptyFieldCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements _$EmptyFieldCopyWith<$Res> {
  __$EmptyFieldCopyWithImpl(
      _EmptyField _value, $Res Function(_EmptyField) _then)
      : super(_value, (v) => _then(v as _EmptyField));

  @override
  _EmptyField get _value => super._value as _EmptyField;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_EmptyField(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_EmptyField implements _EmptyField {
  const _$_EmptyField(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.emptyField(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EmptyField &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$EmptyFieldCopyWith<_EmptyField> get copyWith =>
      __$EmptyFieldCopyWithImpl<_EmptyField>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emptyField(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emptyField != null) {
      return emptyField(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emptyField(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emptyField != null) {
      return emptyField(this);
    }
    return orElse();
  }
}

abstract class _EmptyField implements AuthFailure {
  const factory _EmptyField(String message) = _$_EmptyField;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$EmptyFieldCopyWith<_EmptyField> get copyWith;
}

/// @nodoc
abstract class _$DisplayNameTooLongCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$DisplayNameTooLongCopyWith(
          _DisplayNameTooLong value, $Res Function(_DisplayNameTooLong) then) =
      __$DisplayNameTooLongCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$DisplayNameTooLongCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$DisplayNameTooLongCopyWith<$Res> {
  __$DisplayNameTooLongCopyWithImpl(
      _DisplayNameTooLong _value, $Res Function(_DisplayNameTooLong) _then)
      : super(_value, (v) => _then(v as _DisplayNameTooLong));

  @override
  _DisplayNameTooLong get _value => super._value as _DisplayNameTooLong;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_DisplayNameTooLong(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_DisplayNameTooLong implements _DisplayNameTooLong {
  const _$_DisplayNameTooLong(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.displayNameTooLong(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DisplayNameTooLong &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$DisplayNameTooLongCopyWith<_DisplayNameTooLong> get copyWith =>
      __$DisplayNameTooLongCopyWithImpl<_DisplayNameTooLong>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return displayNameTooLong(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (displayNameTooLong != null) {
      return displayNameTooLong(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return displayNameTooLong(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (displayNameTooLong != null) {
      return displayNameTooLong(this);
    }
    return orElse();
  }
}

abstract class _DisplayNameTooLong implements AuthFailure {
  const factory _DisplayNameTooLong(String message) = _$_DisplayNameTooLong;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$DisplayNameTooLongCopyWith<_DisplayNameTooLong> get copyWith;
}

/// @nodoc
abstract class _$EmailAlreadyInUseCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$EmailAlreadyInUseCopyWith(
          _EmailAlreadyInUse value, $Res Function(_EmailAlreadyInUse) then) =
      __$EmailAlreadyInUseCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$EmailAlreadyInUseCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$EmailAlreadyInUseCopyWith<$Res> {
  __$EmailAlreadyInUseCopyWithImpl(
      _EmailAlreadyInUse _value, $Res Function(_EmailAlreadyInUse) _then)
      : super(_value, (v) => _then(v as _EmailAlreadyInUse));

  @override
  _EmailAlreadyInUse get _value => super._value as _EmailAlreadyInUse;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_EmailAlreadyInUse(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_EmailAlreadyInUse implements _EmailAlreadyInUse {
  const _$_EmailAlreadyInUse(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.emailAlreadyInUse(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EmailAlreadyInUse &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$EmailAlreadyInUseCopyWith<_EmailAlreadyInUse> get copyWith =>
      __$EmailAlreadyInUseCopyWithImpl<_EmailAlreadyInUse>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emailAlreadyInUse(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emailAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class _EmailAlreadyInUse implements AuthFailure {
  const factory _EmailAlreadyInUse(String message) = _$_EmailAlreadyInUse;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$EmailAlreadyInUseCopyWith<_EmailAlreadyInUse> get copyWith;
}

/// @nodoc
abstract class _$CancelledByUserCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$CancelledByUserCopyWith(
          _CancelledByUser value, $Res Function(_CancelledByUser) then) =
      __$CancelledByUserCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$CancelledByUserCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$CancelledByUserCopyWith<$Res> {
  __$CancelledByUserCopyWithImpl(
      _CancelledByUser _value, $Res Function(_CancelledByUser) _then)
      : super(_value, (v) => _then(v as _CancelledByUser));

  @override
  _CancelledByUser get _value => super._value as _CancelledByUser;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_CancelledByUser(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_CancelledByUser implements _CancelledByUser {
  const _$_CancelledByUser(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.cancelledByUser(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _CancelledByUser &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$CancelledByUserCopyWith<_CancelledByUser> get copyWith =>
      __$CancelledByUserCopyWithImpl<_CancelledByUser>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return cancelledByUser(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancelledByUser != null) {
      return cancelledByUser(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return cancelledByUser(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancelledByUser != null) {
      return cancelledByUser(this);
    }
    return orElse();
  }
}

abstract class _CancelledByUser implements AuthFailure {
  const factory _CancelledByUser(String message) = _$_CancelledByUser;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$CancelledByUserCopyWith<_CancelledByUser> get copyWith;
}

/// @nodoc
abstract class _$InvalidEmailAddressCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$InvalidEmailAddressCopyWith(_InvalidEmailAddress value,
          $Res Function(_InvalidEmailAddress) then) =
      __$InvalidEmailAddressCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$InvalidEmailAddressCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$InvalidEmailAddressCopyWith<$Res> {
  __$InvalidEmailAddressCopyWithImpl(
      _InvalidEmailAddress _value, $Res Function(_InvalidEmailAddress) _then)
      : super(_value, (v) => _then(v as _InvalidEmailAddress));

  @override
  _InvalidEmailAddress get _value => super._value as _InvalidEmailAddress;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_InvalidEmailAddress(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_InvalidEmailAddress implements _InvalidEmailAddress {
  const _$_InvalidEmailAddress(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.invalidEmailAddress(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _InvalidEmailAddress &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$InvalidEmailAddressCopyWith<_InvalidEmailAddress> get copyWith =>
      __$InvalidEmailAddressCopyWithImpl<_InvalidEmailAddress>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return invalidEmailAddress(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAddress != null) {
      return invalidEmailAddress(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return invalidEmailAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAddress != null) {
      return invalidEmailAddress(this);
    }
    return orElse();
  }
}

abstract class _InvalidEmailAddress implements AuthFailure {
  const factory _InvalidEmailAddress(String message) = _$_InvalidEmailAddress;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$InvalidEmailAddressCopyWith<_InvalidEmailAddress> get copyWith;
}

/// @nodoc
abstract class _$InvalidEmailAndPasswordCombinationCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$InvalidEmailAndPasswordCombinationCopyWith(
          _InvalidEmailAndPasswordCombination value,
          $Res Function(_InvalidEmailAndPasswordCombination) then) =
      __$InvalidEmailAndPasswordCombinationCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$InvalidEmailAndPasswordCombinationCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$InvalidEmailAndPasswordCombinationCopyWith<$Res> {
  __$InvalidEmailAndPasswordCombinationCopyWithImpl(
      _InvalidEmailAndPasswordCombination _value,
      $Res Function(_InvalidEmailAndPasswordCombination) _then)
      : super(_value, (v) => _then(v as _InvalidEmailAndPasswordCombination));

  @override
  _InvalidEmailAndPasswordCombination get _value =>
      super._value as _InvalidEmailAndPasswordCombination;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_InvalidEmailAndPasswordCombination(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_InvalidEmailAndPasswordCombination
    implements _InvalidEmailAndPasswordCombination {
  const _$_InvalidEmailAndPasswordCombination(this.message)
      : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.invalidEmailAndPasswordCombination(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _InvalidEmailAndPasswordCombination &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$InvalidEmailAndPasswordCombinationCopyWith<
          _InvalidEmailAndPasswordCombination>
      get copyWith => __$InvalidEmailAndPasswordCombinationCopyWithImpl<
          _InvalidEmailAndPasswordCombination>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return invalidEmailAndPasswordCombination(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAndPasswordCombination != null) {
      return invalidEmailAndPasswordCombination(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return invalidEmailAndPasswordCombination(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAndPasswordCombination != null) {
      return invalidEmailAndPasswordCombination(this);
    }
    return orElse();
  }
}

abstract class _InvalidEmailAndPasswordCombination implements AuthFailure {
  const factory _InvalidEmailAndPasswordCombination(String message) =
      _$_InvalidEmailAndPasswordCombination;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$InvalidEmailAndPasswordCombinationCopyWith<
      _InvalidEmailAndPasswordCombination> get copyWith;
}

/// @nodoc
abstract class _$EmailBadlyFormattedCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$EmailBadlyFormattedCopyWith(_EmailBadlyFormatted value,
          $Res Function(_EmailBadlyFormatted) then) =
      __$EmailBadlyFormattedCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$EmailBadlyFormattedCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$EmailBadlyFormattedCopyWith<$Res> {
  __$EmailBadlyFormattedCopyWithImpl(
      _EmailBadlyFormatted _value, $Res Function(_EmailBadlyFormatted) _then)
      : super(_value, (v) => _then(v as _EmailBadlyFormatted));

  @override
  _EmailBadlyFormatted get _value => super._value as _EmailBadlyFormatted;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_EmailBadlyFormatted(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_EmailBadlyFormatted implements _EmailBadlyFormatted {
  const _$_EmailBadlyFormatted(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.emailBadlyFormatted(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EmailBadlyFormatted &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$EmailBadlyFormattedCopyWith<_EmailBadlyFormatted> get copyWith =>
      __$EmailBadlyFormattedCopyWithImpl<_EmailBadlyFormatted>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emailBadlyFormatted(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emailBadlyFormatted != null) {
      return emailBadlyFormatted(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emailBadlyFormatted(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emailBadlyFormatted != null) {
      return emailBadlyFormatted(this);
    }
    return orElse();
  }
}

abstract class _EmailBadlyFormatted implements AuthFailure {
  const factory _EmailBadlyFormatted(String message) = _$_EmailBadlyFormatted;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$EmailBadlyFormattedCopyWith<_EmailBadlyFormatted> get copyWith;
}

/// @nodoc
abstract class _$WeakPasswordCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$WeakPasswordCopyWith(
          _WeakPassword value, $Res Function(_WeakPassword) then) =
      __$WeakPasswordCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$WeakPasswordCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements _$WeakPasswordCopyWith<$Res> {
  __$WeakPasswordCopyWithImpl(
      _WeakPassword _value, $Res Function(_WeakPassword) _then)
      : super(_value, (v) => _then(v as _WeakPassword));

  @override
  _WeakPassword get _value => super._value as _WeakPassword;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_WeakPassword(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_WeakPassword implements _WeakPassword {
  const _$_WeakPassword(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.weakPassword(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _WeakPassword &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$WeakPasswordCopyWith<_WeakPassword> get copyWith =>
      __$WeakPasswordCopyWithImpl<_WeakPassword>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return weakPassword(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (weakPassword != null) {
      return weakPassword(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return weakPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (weakPassword != null) {
      return weakPassword(this);
    }
    return orElse();
  }
}

abstract class _WeakPassword implements AuthFailure {
  const factory _WeakPassword(String message) = _$_WeakPassword;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$WeakPasswordCopyWith<_WeakPassword> get copyWith;
}

/// @nodoc
abstract class _$ServerFailureCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$ServerFailureCopyWith(
          _ServerFailure value, $Res Function(_ServerFailure) then) =
      __$ServerFailureCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$ServerFailureCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements _$ServerFailureCopyWith<$Res> {
  __$ServerFailureCopyWithImpl(
      _ServerFailure _value, $Res Function(_ServerFailure) _then)
      : super(_value, (v) => _then(v as _ServerFailure));

  @override
  _ServerFailure get _value => super._value as _ServerFailure;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_ServerFailure(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_ServerFailure implements _ServerFailure {
  const _$_ServerFailure(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.serverFailure(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ServerFailure &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$ServerFailureCopyWith<_ServerFailure> get copyWith =>
      __$ServerFailureCopyWithImpl<_ServerFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return serverFailure(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (serverFailure != null) {
      return serverFailure(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return serverFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (serverFailure != null) {
      return serverFailure(this);
    }
    return orElse();
  }
}

abstract class _ServerFailure implements AuthFailure {
  const factory _ServerFailure(String message) = _$_ServerFailure;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$ServerFailureCopyWith<_ServerFailure> get copyWith;
}

/// @nodoc
abstract class _$UnknownFailureCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$UnknownFailureCopyWith(
          _UnknownFailure value, $Res Function(_UnknownFailure) then) =
      __$UnknownFailureCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$UnknownFailureCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$UnknownFailureCopyWith<$Res> {
  __$UnknownFailureCopyWithImpl(
      _UnknownFailure _value, $Res Function(_UnknownFailure) _then)
      : super(_value, (v) => _then(v as _UnknownFailure));

  @override
  _UnknownFailure get _value => super._value as _UnknownFailure;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_UnknownFailure(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_UnknownFailure implements _UnknownFailure {
  const _$_UnknownFailure(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.unknownFailure(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _UnknownFailure &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$UnknownFailureCopyWith<_UnknownFailure> get copyWith =>
      __$UnknownFailureCopyWithImpl<_UnknownFailure>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return unknownFailure(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unknownFailure != null) {
      return unknownFailure(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return unknownFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unknownFailure != null) {
      return unknownFailure(this);
    }
    return orElse();
  }
}

abstract class _UnknownFailure implements AuthFailure {
  const factory _UnknownFailure(String message) = _$_UnknownFailure;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$UnknownFailureCopyWith<_UnknownFailure> get copyWith;
}

/// @nodoc
abstract class _$PasswordsDontMatchCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$PasswordsDontMatchCopyWith(
          _PasswordsDontMatch value, $Res Function(_PasswordsDontMatch) then) =
      __$PasswordsDontMatchCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$PasswordsDontMatchCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$PasswordsDontMatchCopyWith<$Res> {
  __$PasswordsDontMatchCopyWithImpl(
      _PasswordsDontMatch _value, $Res Function(_PasswordsDontMatch) _then)
      : super(_value, (v) => _then(v as _PasswordsDontMatch));

  @override
  _PasswordsDontMatch get _value => super._value as _PasswordsDontMatch;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_PasswordsDontMatch(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_PasswordsDontMatch implements _PasswordsDontMatch {
  const _$_PasswordsDontMatch(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.passwordsDontMatch(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PasswordsDontMatch &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$PasswordsDontMatchCopyWith<_PasswordsDontMatch> get copyWith =>
      __$PasswordsDontMatchCopyWithImpl<_PasswordsDontMatch>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return passwordsDontMatch(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (passwordsDontMatch != null) {
      return passwordsDontMatch(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return passwordsDontMatch(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (passwordsDontMatch != null) {
      return passwordsDontMatch(this);
    }
    return orElse();
  }
}

abstract class _PasswordsDontMatch implements AuthFailure {
  const factory _PasswordsDontMatch(String message) = _$_PasswordsDontMatch;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$PasswordsDontMatchCopyWith<_PasswordsDontMatch> get copyWith;
}

/// @nodoc
abstract class _$NotAuthenticatedCopyWith<$Res>
    implements $AuthFailureCopyWith<$Res> {
  factory _$NotAuthenticatedCopyWith(
          _NotAuthenticated value, $Res Function(_NotAuthenticated) then) =
      __$NotAuthenticatedCopyWithImpl<$Res>;
  @override
  $Res call({String message});
}

/// @nodoc
class __$NotAuthenticatedCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$NotAuthenticatedCopyWith<$Res> {
  __$NotAuthenticatedCopyWithImpl(
      _NotAuthenticated _value, $Res Function(_NotAuthenticated) _then)
      : super(_value, (v) => _then(v as _NotAuthenticated));

  @override
  _NotAuthenticated get _value => super._value as _NotAuthenticated;

  @override
  $Res call({
    Object message = freezed,
  }) {
    return _then(_NotAuthenticated(
      message == freezed ? _value.message : message as String,
    ));
  }
}

/// @nodoc
class _$_NotAuthenticated implements _NotAuthenticated {
  const _$_NotAuthenticated(this.message) : assert(message != null);

  @override
  final String message;

  @override
  String toString() {
    return 'AuthFailure.notAuthenticated(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _NotAuthenticated &&
            (identical(other.message, message) ||
                const DeepCollectionEquality().equals(other.message, message)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(message);

  @JsonKey(ignore: true)
  @override
  _$NotAuthenticatedCopyWith<_NotAuthenticated> get copyWith =>
      __$NotAuthenticatedCopyWithImpl<_NotAuthenticated>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(String message),
    @required TResult displayNameTooLong(String message),
    @required TResult emailAlreadyInUse(String message),
    @required TResult cancelledByUser(String message),
    @required TResult invalidEmailAddress(String message),
    @required TResult invalidEmailAndPasswordCombination(String message),
    @required TResult emailBadlyFormatted(String message),
    @required TResult weakPassword(String message),
    @required TResult serverFailure(String message),
    @required TResult unknownFailure(String message),
    @required TResult passwordsDontMatch(String message),
    @required TResult notAuthenticated(String message),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return notAuthenticated(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(String message),
    TResult displayNameTooLong(String message),
    TResult emailAlreadyInUse(String message),
    TResult cancelledByUser(String message),
    TResult invalidEmailAddress(String message),
    TResult invalidEmailAndPasswordCombination(String message),
    TResult emailBadlyFormatted(String message),
    TResult weakPassword(String message),
    TResult serverFailure(String message),
    TResult unknownFailure(String message),
    TResult passwordsDontMatch(String message),
    TResult notAuthenticated(String message),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notAuthenticated != null) {
      return notAuthenticated(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return notAuthenticated(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notAuthenticated != null) {
      return notAuthenticated(this);
    }
    return orElse();
  }
}

abstract class _NotAuthenticated implements AuthFailure {
  const factory _NotAuthenticated(String message) = _$_NotAuthenticated;

  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$NotAuthenticatedCopyWith<_NotAuthenticated> get copyWith;
}
