// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'auth_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$AuthFailureTearOff {
  const _$AuthFailureTearOff();

// ignore: unused_element
  _EmptyField emptyField() {
    return const _EmptyField();
  }

// ignore: unused_element
  _DisplayNameTooLong displayNameTooLong() {
    return const _DisplayNameTooLong();
  }

// ignore: unused_element
  _EmailAlreadyInUse emailAlreadyInUse() {
    return const _EmailAlreadyInUse();
  }

// ignore: unused_element
  _CancelledByUser cancelledByUser() {
    return const _CancelledByUser();
  }

// ignore: unused_element
  _InvalidEmailAddress invalidEmailAddress() {
    return const _InvalidEmailAddress();
  }

// ignore: unused_element
  _InvalidEmailAndPasswordCombination invalidEmailAndPasswordCombination() {
    return const _InvalidEmailAndPasswordCombination();
  }

// ignore: unused_element
  _EmailBadlyFormatted emailBadlyFormatted() {
    return const _EmailBadlyFormatted();
  }

// ignore: unused_element
  _WeakPassword weakPassword() {
    return const _WeakPassword();
  }

// ignore: unused_element
  _ServerFailure serverFailure() {
    return const _ServerFailure();
  }

// ignore: unused_element
  _UnknownFailure unknownFailure() {
    return const _UnknownFailure();
  }

// ignore: unused_element
  _PasswordsDontMatch passwordsDontMatch() {
    return const _PasswordsDontMatch();
  }

// ignore: unused_element
  _NotAuthenticated notAuthenticated() {
    return const _NotAuthenticated();
  }
}

/// @nodoc
// ignore: unused_element
const $AuthFailure = _$AuthFailureTearOff();

/// @nodoc
mixin _$AuthFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $AuthFailureCopyWith<$Res> {
  factory $AuthFailureCopyWith(
          AuthFailure value, $Res Function(AuthFailure) then) =
      _$AuthFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthFailureCopyWithImpl<$Res> implements $AuthFailureCopyWith<$Res> {
  _$AuthFailureCopyWithImpl(this._value, this._then);

  final AuthFailure _value;
  // ignore: unused_field
  final $Res Function(AuthFailure) _then;
}

/// @nodoc
abstract class _$EmptyFieldCopyWith<$Res> {
  factory _$EmptyFieldCopyWith(
          _EmptyField value, $Res Function(_EmptyField) then) =
      __$EmptyFieldCopyWithImpl<$Res>;
}

/// @nodoc
class __$EmptyFieldCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements _$EmptyFieldCopyWith<$Res> {
  __$EmptyFieldCopyWithImpl(
      _EmptyField _value, $Res Function(_EmptyField) _then)
      : super(_value, (v) => _then(v as _EmptyField));

  @override
  _EmptyField get _value => super._value as _EmptyField;
}

/// @nodoc
class _$_EmptyField implements _EmptyField {
  const _$_EmptyField();

  @override
  String toString() {
    return 'AuthFailure.emptyField()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _EmptyField);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emptyField();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emptyField != null) {
      return emptyField();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emptyField(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emptyField != null) {
      return emptyField(this);
    }
    return orElse();
  }
}

abstract class _EmptyField implements AuthFailure {
  const factory _EmptyField() = _$_EmptyField;
}

/// @nodoc
abstract class _$DisplayNameTooLongCopyWith<$Res> {
  factory _$DisplayNameTooLongCopyWith(
          _DisplayNameTooLong value, $Res Function(_DisplayNameTooLong) then) =
      __$DisplayNameTooLongCopyWithImpl<$Res>;
}

/// @nodoc
class __$DisplayNameTooLongCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$DisplayNameTooLongCopyWith<$Res> {
  __$DisplayNameTooLongCopyWithImpl(
      _DisplayNameTooLong _value, $Res Function(_DisplayNameTooLong) _then)
      : super(_value, (v) => _then(v as _DisplayNameTooLong));

  @override
  _DisplayNameTooLong get _value => super._value as _DisplayNameTooLong;
}

/// @nodoc
class _$_DisplayNameTooLong implements _DisplayNameTooLong {
  const _$_DisplayNameTooLong();

  @override
  String toString() {
    return 'AuthFailure.displayNameTooLong()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _DisplayNameTooLong);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return displayNameTooLong();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (displayNameTooLong != null) {
      return displayNameTooLong();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return displayNameTooLong(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (displayNameTooLong != null) {
      return displayNameTooLong(this);
    }
    return orElse();
  }
}

abstract class _DisplayNameTooLong implements AuthFailure {
  const factory _DisplayNameTooLong() = _$_DisplayNameTooLong;
}

/// @nodoc
abstract class _$EmailAlreadyInUseCopyWith<$Res> {
  factory _$EmailAlreadyInUseCopyWith(
          _EmailAlreadyInUse value, $Res Function(_EmailAlreadyInUse) then) =
      __$EmailAlreadyInUseCopyWithImpl<$Res>;
}

/// @nodoc
class __$EmailAlreadyInUseCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$EmailAlreadyInUseCopyWith<$Res> {
  __$EmailAlreadyInUseCopyWithImpl(
      _EmailAlreadyInUse _value, $Res Function(_EmailAlreadyInUse) _then)
      : super(_value, (v) => _then(v as _EmailAlreadyInUse));

  @override
  _EmailAlreadyInUse get _value => super._value as _EmailAlreadyInUse;
}

/// @nodoc
class _$_EmailAlreadyInUse implements _EmailAlreadyInUse {
  const _$_EmailAlreadyInUse();

  @override
  String toString() {
    return 'AuthFailure.emailAlreadyInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _EmailAlreadyInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emailAlreadyInUse();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emailAlreadyInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emailAlreadyInUse != null) {
      return emailAlreadyInUse(this);
    }
    return orElse();
  }
}

abstract class _EmailAlreadyInUse implements AuthFailure {
  const factory _EmailAlreadyInUse() = _$_EmailAlreadyInUse;
}

/// @nodoc
abstract class _$CancelledByUserCopyWith<$Res> {
  factory _$CancelledByUserCopyWith(
          _CancelledByUser value, $Res Function(_CancelledByUser) then) =
      __$CancelledByUserCopyWithImpl<$Res>;
}

/// @nodoc
class __$CancelledByUserCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$CancelledByUserCopyWith<$Res> {
  __$CancelledByUserCopyWithImpl(
      _CancelledByUser _value, $Res Function(_CancelledByUser) _then)
      : super(_value, (v) => _then(v as _CancelledByUser));

  @override
  _CancelledByUser get _value => super._value as _CancelledByUser;
}

/// @nodoc
class _$_CancelledByUser implements _CancelledByUser {
  const _$_CancelledByUser();

  @override
  String toString() {
    return 'AuthFailure.cancelledByUser()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _CancelledByUser);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return cancelledByUser();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancelledByUser != null) {
      return cancelledByUser();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return cancelledByUser(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (cancelledByUser != null) {
      return cancelledByUser(this);
    }
    return orElse();
  }
}

abstract class _CancelledByUser implements AuthFailure {
  const factory _CancelledByUser() = _$_CancelledByUser;
}

/// @nodoc
abstract class _$InvalidEmailAddressCopyWith<$Res> {
  factory _$InvalidEmailAddressCopyWith(_InvalidEmailAddress value,
          $Res Function(_InvalidEmailAddress) then) =
      __$InvalidEmailAddressCopyWithImpl<$Res>;
}

/// @nodoc
class __$InvalidEmailAddressCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$InvalidEmailAddressCopyWith<$Res> {
  __$InvalidEmailAddressCopyWithImpl(
      _InvalidEmailAddress _value, $Res Function(_InvalidEmailAddress) _then)
      : super(_value, (v) => _then(v as _InvalidEmailAddress));

  @override
  _InvalidEmailAddress get _value => super._value as _InvalidEmailAddress;
}

/// @nodoc
class _$_InvalidEmailAddress implements _InvalidEmailAddress {
  const _$_InvalidEmailAddress();

  @override
  String toString() {
    return 'AuthFailure.invalidEmailAddress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _InvalidEmailAddress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return invalidEmailAddress();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAddress != null) {
      return invalidEmailAddress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return invalidEmailAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAddress != null) {
      return invalidEmailAddress(this);
    }
    return orElse();
  }
}

abstract class _InvalidEmailAddress implements AuthFailure {
  const factory _InvalidEmailAddress() = _$_InvalidEmailAddress;
}

/// @nodoc
abstract class _$InvalidEmailAndPasswordCombinationCopyWith<$Res> {
  factory _$InvalidEmailAndPasswordCombinationCopyWith(
          _InvalidEmailAndPasswordCombination value,
          $Res Function(_InvalidEmailAndPasswordCombination) then) =
      __$InvalidEmailAndPasswordCombinationCopyWithImpl<$Res>;
}

/// @nodoc
class __$InvalidEmailAndPasswordCombinationCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$InvalidEmailAndPasswordCombinationCopyWith<$Res> {
  __$InvalidEmailAndPasswordCombinationCopyWithImpl(
      _InvalidEmailAndPasswordCombination _value,
      $Res Function(_InvalidEmailAndPasswordCombination) _then)
      : super(_value, (v) => _then(v as _InvalidEmailAndPasswordCombination));

  @override
  _InvalidEmailAndPasswordCombination get _value =>
      super._value as _InvalidEmailAndPasswordCombination;
}

/// @nodoc
class _$_InvalidEmailAndPasswordCombination
    implements _InvalidEmailAndPasswordCombination {
  const _$_InvalidEmailAndPasswordCombination();

  @override
  String toString() {
    return 'AuthFailure.invalidEmailAndPasswordCombination()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _InvalidEmailAndPasswordCombination);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return invalidEmailAndPasswordCombination();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAndPasswordCombination != null) {
      return invalidEmailAndPasswordCombination();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return invalidEmailAndPasswordCombination(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (invalidEmailAndPasswordCombination != null) {
      return invalidEmailAndPasswordCombination(this);
    }
    return orElse();
  }
}

abstract class _InvalidEmailAndPasswordCombination implements AuthFailure {
  const factory _InvalidEmailAndPasswordCombination() =
      _$_InvalidEmailAndPasswordCombination;
}

/// @nodoc
abstract class _$EmailBadlyFormattedCopyWith<$Res> {
  factory _$EmailBadlyFormattedCopyWith(_EmailBadlyFormatted value,
          $Res Function(_EmailBadlyFormatted) then) =
      __$EmailBadlyFormattedCopyWithImpl<$Res>;
}

/// @nodoc
class __$EmailBadlyFormattedCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$EmailBadlyFormattedCopyWith<$Res> {
  __$EmailBadlyFormattedCopyWithImpl(
      _EmailBadlyFormatted _value, $Res Function(_EmailBadlyFormatted) _then)
      : super(_value, (v) => _then(v as _EmailBadlyFormatted));

  @override
  _EmailBadlyFormatted get _value => super._value as _EmailBadlyFormatted;
}

/// @nodoc
class _$_EmailBadlyFormatted implements _EmailBadlyFormatted {
  const _$_EmailBadlyFormatted();

  @override
  String toString() {
    return 'AuthFailure.emailBadlyFormatted()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _EmailBadlyFormatted);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emailBadlyFormatted();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emailBadlyFormatted != null) {
      return emailBadlyFormatted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return emailBadlyFormatted(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (emailBadlyFormatted != null) {
      return emailBadlyFormatted(this);
    }
    return orElse();
  }
}

abstract class _EmailBadlyFormatted implements AuthFailure {
  const factory _EmailBadlyFormatted() = _$_EmailBadlyFormatted;
}

/// @nodoc
abstract class _$WeakPasswordCopyWith<$Res> {
  factory _$WeakPasswordCopyWith(
          _WeakPassword value, $Res Function(_WeakPassword) then) =
      __$WeakPasswordCopyWithImpl<$Res>;
}

/// @nodoc
class __$WeakPasswordCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements _$WeakPasswordCopyWith<$Res> {
  __$WeakPasswordCopyWithImpl(
      _WeakPassword _value, $Res Function(_WeakPassword) _then)
      : super(_value, (v) => _then(v as _WeakPassword));

  @override
  _WeakPassword get _value => super._value as _WeakPassword;
}

/// @nodoc
class _$_WeakPassword implements _WeakPassword {
  const _$_WeakPassword();

  @override
  String toString() {
    return 'AuthFailure.weakPassword()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _WeakPassword);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return weakPassword();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (weakPassword != null) {
      return weakPassword();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return weakPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (weakPassword != null) {
      return weakPassword(this);
    }
    return orElse();
  }
}

abstract class _WeakPassword implements AuthFailure {
  const factory _WeakPassword() = _$_WeakPassword;
}

/// @nodoc
abstract class _$ServerFailureCopyWith<$Res> {
  factory _$ServerFailureCopyWith(
          _ServerFailure value, $Res Function(_ServerFailure) then) =
      __$ServerFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$ServerFailureCopyWithImpl<$Res> extends _$AuthFailureCopyWithImpl<$Res>
    implements _$ServerFailureCopyWith<$Res> {
  __$ServerFailureCopyWithImpl(
      _ServerFailure _value, $Res Function(_ServerFailure) _then)
      : super(_value, (v) => _then(v as _ServerFailure));

  @override
  _ServerFailure get _value => super._value as _ServerFailure;
}

/// @nodoc
class _$_ServerFailure implements _ServerFailure {
  const _$_ServerFailure();

  @override
  String toString() {
    return 'AuthFailure.serverFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ServerFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return serverFailure();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (serverFailure != null) {
      return serverFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return serverFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (serverFailure != null) {
      return serverFailure(this);
    }
    return orElse();
  }
}

abstract class _ServerFailure implements AuthFailure {
  const factory _ServerFailure() = _$_ServerFailure;
}

/// @nodoc
abstract class _$UnknownFailureCopyWith<$Res> {
  factory _$UnknownFailureCopyWith(
          _UnknownFailure value, $Res Function(_UnknownFailure) then) =
      __$UnknownFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$UnknownFailureCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$UnknownFailureCopyWith<$Res> {
  __$UnknownFailureCopyWithImpl(
      _UnknownFailure _value, $Res Function(_UnknownFailure) _then)
      : super(_value, (v) => _then(v as _UnknownFailure));

  @override
  _UnknownFailure get _value => super._value as _UnknownFailure;
}

/// @nodoc
class _$_UnknownFailure implements _UnknownFailure {
  const _$_UnknownFailure();

  @override
  String toString() {
    return 'AuthFailure.unknownFailure()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _UnknownFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return unknownFailure();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unknownFailure != null) {
      return unknownFailure();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return unknownFailure(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (unknownFailure != null) {
      return unknownFailure(this);
    }
    return orElse();
  }
}

abstract class _UnknownFailure implements AuthFailure {
  const factory _UnknownFailure() = _$_UnknownFailure;
}

/// @nodoc
abstract class _$PasswordsDontMatchCopyWith<$Res> {
  factory _$PasswordsDontMatchCopyWith(
          _PasswordsDontMatch value, $Res Function(_PasswordsDontMatch) then) =
      __$PasswordsDontMatchCopyWithImpl<$Res>;
}

/// @nodoc
class __$PasswordsDontMatchCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$PasswordsDontMatchCopyWith<$Res> {
  __$PasswordsDontMatchCopyWithImpl(
      _PasswordsDontMatch _value, $Res Function(_PasswordsDontMatch) _then)
      : super(_value, (v) => _then(v as _PasswordsDontMatch));

  @override
  _PasswordsDontMatch get _value => super._value as _PasswordsDontMatch;
}

/// @nodoc
class _$_PasswordsDontMatch implements _PasswordsDontMatch {
  const _$_PasswordsDontMatch();

  @override
  String toString() {
    return 'AuthFailure.passwordsDontMatch()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PasswordsDontMatch);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return passwordsDontMatch();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (passwordsDontMatch != null) {
      return passwordsDontMatch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return passwordsDontMatch(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (passwordsDontMatch != null) {
      return passwordsDontMatch(this);
    }
    return orElse();
  }
}

abstract class _PasswordsDontMatch implements AuthFailure {
  const factory _PasswordsDontMatch() = _$_PasswordsDontMatch;
}

/// @nodoc
abstract class _$NotAuthenticatedCopyWith<$Res> {
  factory _$NotAuthenticatedCopyWith(
          _NotAuthenticated value, $Res Function(_NotAuthenticated) then) =
      __$NotAuthenticatedCopyWithImpl<$Res>;
}

/// @nodoc
class __$NotAuthenticatedCopyWithImpl<$Res>
    extends _$AuthFailureCopyWithImpl<$Res>
    implements _$NotAuthenticatedCopyWith<$Res> {
  __$NotAuthenticatedCopyWithImpl(
      _NotAuthenticated _value, $Res Function(_NotAuthenticated) _then)
      : super(_value, (v) => _then(v as _NotAuthenticated));

  @override
  _NotAuthenticated get _value => super._value as _NotAuthenticated;
}

/// @nodoc
class _$_NotAuthenticated implements _NotAuthenticated {
  const _$_NotAuthenticated();

  @override
  String toString() {
    return 'AuthFailure.notAuthenticated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _NotAuthenticated);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult emptyField(),
    @required TResult displayNameTooLong(),
    @required TResult emailAlreadyInUse(),
    @required TResult cancelledByUser(),
    @required TResult invalidEmailAddress(),
    @required TResult invalidEmailAndPasswordCombination(),
    @required TResult emailBadlyFormatted(),
    @required TResult weakPassword(),
    @required TResult serverFailure(),
    @required TResult unknownFailure(),
    @required TResult passwordsDontMatch(),
    @required TResult notAuthenticated(),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return notAuthenticated();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult emptyField(),
    TResult displayNameTooLong(),
    TResult emailAlreadyInUse(),
    TResult cancelledByUser(),
    TResult invalidEmailAddress(),
    TResult invalidEmailAndPasswordCombination(),
    TResult emailBadlyFormatted(),
    TResult weakPassword(),
    TResult serverFailure(),
    TResult unknownFailure(),
    TResult passwordsDontMatch(),
    TResult notAuthenticated(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notAuthenticated != null) {
      return notAuthenticated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult emptyField(_EmptyField value),
    @required TResult displayNameTooLong(_DisplayNameTooLong value),
    @required TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    @required TResult cancelledByUser(_CancelledByUser value),
    @required TResult invalidEmailAddress(_InvalidEmailAddress value),
    @required
        TResult invalidEmailAndPasswordCombination(
            _InvalidEmailAndPasswordCombination value),
    @required TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    @required TResult weakPassword(_WeakPassword value),
    @required TResult serverFailure(_ServerFailure value),
    @required TResult unknownFailure(_UnknownFailure value),
    @required TResult passwordsDontMatch(_PasswordsDontMatch value),
    @required TResult notAuthenticated(_NotAuthenticated value),
  }) {
    assert(emptyField != null);
    assert(displayNameTooLong != null);
    assert(emailAlreadyInUse != null);
    assert(cancelledByUser != null);
    assert(invalidEmailAddress != null);
    assert(invalidEmailAndPasswordCombination != null);
    assert(emailBadlyFormatted != null);
    assert(weakPassword != null);
    assert(serverFailure != null);
    assert(unknownFailure != null);
    assert(passwordsDontMatch != null);
    assert(notAuthenticated != null);
    return notAuthenticated(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult emptyField(_EmptyField value),
    TResult displayNameTooLong(_DisplayNameTooLong value),
    TResult emailAlreadyInUse(_EmailAlreadyInUse value),
    TResult cancelledByUser(_CancelledByUser value),
    TResult invalidEmailAddress(_InvalidEmailAddress value),
    TResult invalidEmailAndPasswordCombination(
        _InvalidEmailAndPasswordCombination value),
    TResult emailBadlyFormatted(_EmailBadlyFormatted value),
    TResult weakPassword(_WeakPassword value),
    TResult serverFailure(_ServerFailure value),
    TResult unknownFailure(_UnknownFailure value),
    TResult passwordsDontMatch(_PasswordsDontMatch value),
    TResult notAuthenticated(_NotAuthenticated value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (notAuthenticated != null) {
      return notAuthenticated(this);
    }
    return orElse();
  }
}

abstract class _NotAuthenticated implements AuthFailure {
  const factory _NotAuthenticated() = _$_NotAuthenticated;
}
